<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Extract and save frames from your videos easily online.">
    <title>Video Frame Saver - Extract Frames Online</title>
    <link rel="icon" href="https://www.svgrepo.com/show/13691/video-camera.svg" type="image/svg+xml">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #f4f6fa;
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            min-height: 100vh;
            min-width: 100vw;
            box-sizing: border-box;
        }
        .container {
            background: #fff;
            box-shadow: 0 4px 24px rgba(0,0,0,0.08);
            border-radius: 0;
            padding: 0;
            margin: 0;
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }
        h1 {
            font-size: 1.6rem;
            margin: 24px 0 12px 0;
            color: #2d3748;
        }
        input[type="file"] {
            margin-bottom: 18px;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            align-items: center;
        }
        .controls label {
            font-size: 0.95rem;
            color: #2563eb;
        }
        .precision-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        .precision-controls label {
            color: #2563eb;
            font-size: 0.95rem;
        }
        .progress-bar-container {
            width: 90vw;
            max-width: 900px;
            margin: 16px 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .progress-bar-label {
            font-size: 0.95rem;
            color: #2563eb;
            min-width: 80px;
        }
        input[type="range"] {
            width: 100%;
            max-width: 700px;
        }
        .frame-time {
            font-size: 0.95rem;
            color: #64748b;
            min-width: 60px;
            text-align: right;
        }
        video {
            width: 100vw;
            height: 60vh;
            max-width: 100vw;
            max-height: 60vh;
            border-radius: 0;
            margin-bottom: 18px;
            background: #222;
            object-fit: contain;
        }
        button {
            background: #2563eb;
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 10px 22px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 8px;
        }
        button:disabled {
            background: #a5b4fc;
            cursor: not-allowed;
        }
        .info {
            font-size: 0.95rem;
            color: #64748b;
            margin-bottom: 12px;
            text-align: center;
        }
        .warning {
            color: #e53e3e;
            font-size: 0.95rem;
            margin-bottom: 10px;
            text-align: center;
            display: none;
        }
        .loading-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            width: 100vw; height: 100vh;
            background: rgba(244,246,250,0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            font-size: 1.3rem;
            color: #2563eb;
            transition: opacity 0.3s;
        }
        .loading-spinner {
            border: 4px solid #e0e7ef;
            border-top: 4px solid #2563eb;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-right: 18px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg);}
            100% { transform: rotate(360deg);}
        }
        @media (max-width: 700px) {
            .progress-bar-container {
                width: 98vw;
                max-width: 98vw;
            }
            video {
                height: 40vh;
                max-height: 40vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Video Frame Saver</h1>
        <div class="info">Paste or upload a video, select a frame, and save it to your PC.</div>
        <div class="warning" id="storageWarning">
            Note: Downloading many frames may use significant storage. Misuse may fill your disk!
        </div>
        <input type="file" id="videoInput" accept="video/*">
        <div class="controls">
            <label>
                Frame interval (seconds): 
                <input type="number" id="intervalInput" min="0.1" step="0.1" value="0.5" style="width:60px;">
            </label>
            <label>
                <input type="checkbox" id="zipCheckbox"> Download all frames in a folder (ZIP)
            </label>
        </div>
        <div class="precision-controls">
            <label for="msStepInput">Step (ms):</label>
            <input type="number" id="msStepInput" min="1" max="1000" value="10" style="width:60px;">
        </div>
        <video id="video" controls style="display:none"></video>
        <div class="progress-bar-container" id="progressBarContainer" style="display:none;">
            <span class="progress-bar-label">Time:</span>
            <input type="range" id="frameSlider" min="0" max="0" step="0.01" value="0">
            <span class="frame-time" id="frameTimeLabel">00:00.000</span>
        </div>
        <button id="saveBtn" disabled>Save Selected Frame</button>
        <button id="saveAllBtn" disabled>Download All Frames</button>
        <div class="loading-overlay" id="loadingOverlay" style="display:none;">
            <div class="loading-spinner"></div>
            <span>Loading video...</span>
        </div>
    </div>
    <script>
        const videoInput = document.getElementById('videoInput');
        const video = document.getElementById('video');
        const saveBtn = document.getElementById('saveBtn');
        const saveAllBtn = document.getElementById('saveAllBtn');
        const intervalInput = document.getElementById('intervalInput');
        const zipCheckbox = document.getElementById('zipCheckbox');
        const frameSlider = document.getElementById('frameSlider');
        const frameTimeLabel = document.getElementById('frameTimeLabel');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const storageWarning = document.getElementById('storageWarning');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const msStepInput = document.getElementById('msStepInput');
        let duration = 0;
        let videoURL = '';
        let frameInterval = parseFloat(intervalInput.value);
        let msStep = parseInt(msStepInput.value, 10);

        intervalInput.addEventListener('input', function() {
            frameInterval = Math.max(0.1, parseFloat(this.value) || 0.5);
        });

        msStepInput.addEventListener('input', function() {
            msStep = Math.max(1, Math.min(1000, parseInt(this.value, 10) || 10));
            frameSlider.step = (msStep / 1000).toFixed(3);
        });

        videoInput.addEventListener('change', function() {
            const file = this.files[0];
            if (file) {
                loadingOverlay.style.display = 'flex';
                videoURL = URL.createObjectURL(file);
                video.src = videoURL;
                video.style.display = 'none';
                progressBarContainer.style.display = 'none';
                saveBtn.disabled = true;
                saveAllBtn.disabled = true;

                video.load();
                video.muted = true;
                video.currentTime = 0;
                video.play();

                let gotDuration = false;
                video.onloadedmetadata = function() {
                    video.currentTime = video.duration;
                };
                video.onseeked = function() {
                    if (!gotDuration) {
                        gotDuration = true;
                        duration = video.duration;
                        video.pause();
                        video.currentTime = 0;
                        video.style.display = 'block';
                        frameSlider.max = duration.toFixed(2);
                        frameSlider.value = 0;
                        frameSlider.step = 0.01;
                        updateFrameTimeLabel();
                        progressBarContainer.style.display = 'flex';
                        saveBtn.disabled = false;
                        saveAllBtn.disabled = false;
                        seekToTime(0);
                        loadingOverlay.style.display = 'none';
                    }
                };
            }
        });

        video.addEventListener('loadedmetadata', function() {
            duration = video.duration;
            frameSlider.max = duration.toFixed(2);
            frameSlider.value = 0;
            frameSlider.step = 0.01;
            updateFrameTimeLabel();
            progressBarContainer.style.display = 'flex';
            saveBtn.disabled = false;
            saveAllBtn.disabled = false;
            seekToTime(0);
            frameSlider.step = (msStep / 1000).toFixed(3);
        });

        frameSlider.addEventListener('input', function() {
            updateFrameTimeLabel();
            seekToTime(parseFloat(frameSlider.value));
        });

        frameSlider.addEventListener('click', function(e) {
            const rect = frameSlider.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = x / rect.width;
            const newTime = percent * duration;
            frameSlider.value = newTime.toFixed(3);
            updateFrameTimeLabel();
            seekToTime(parseFloat(frameSlider.value));
        });

        frameSlider.addEventListener('wheel', function(e) {
            e.preventDefault();
            let val = parseFloat(frameSlider.value);
            let delta = (msStep / 1000) * (e.deltaY < 0 ? 1 : -1);
            val = Math.max(0, Math.min(duration, val + delta));
            frameSlider.value = val.toFixed(3);
            updateFrameTimeLabel();
            seekToTime(val);
        });

        frameSlider.addEventListener('keydown', function(e) {
            let val = parseFloat(frameSlider.value);
            if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                val = Math.max(0, val - msStep / 1000);
            } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                val = Math.min(duration, val + msStep / 1000);
            } else {
                return;
            }
            frameSlider.value = val.toFixed(3);
            updateFrameTimeLabel();
            seekToTime(val);
            e.preventDefault();
        });

        function updateFrameTimeLabel() {
            const t = parseFloat(frameSlider.value);
            const min = Math.floor(t / 60);
            const sec = Math.floor(t % 60);
            const ms = Math.round((t - Math.floor(t)) * 1000);
            frameTimeLabel.textContent = `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
        }

        function seekToTime(time) {
            video.currentTime = Math.min(time, duration - 0.01);
        }

        async function saveBlobWithPicker(blob, defaultName) {
            if (window.showSaveFilePicker) {
                const handle = await window.showSaveFilePicker({
                    suggestedName: defaultName,
                    types: [{
                        description: 'PNG Image',
                        accept: {'image/png': ['.png']}
                    }]
                });
                const writable = await handle.createWritable();
                await writable.write(blob);
                await writable.close();
            } else {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = defaultName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        }

        saveBtn.addEventListener('click', async function() {
            if (!confirm('Do you want to download this frame?')) return;
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            canvas.toBlob(async function(blob) {
                await saveBlobWithPicker(blob, `frame_${parseFloat(frameSlider.value).toFixed(2)}s.png`);
            }, 'image/png');
        });

        saveAllBtn.addEventListener('click', async function() {
            storageWarning.style.display = 'block';
            setTimeout(() => { storageWarning.style.display = 'none'; }, 6000);
            if (!confirm('Download ALL frames? This may use a lot of storage!')) return;
            const zipMode = zipCheckbox.checked;
            const totalFrames = Math.floor(duration / frameInterval);
            if (zipMode) {
                const zip = new JSZip();
                for (let i = 0; i < totalFrames; i++) {
                    await extractFrameToZip(i, zip);
                }
                zip.generateAsync({type:"blob"}).then(async function(content) {
                    if (window.showSaveFilePicker) {
                        const handle = await window.showSaveFilePicker({
                            suggestedName: "frames.zip",
                            types: [{
                                description: 'ZIP Archive',
                                accept: {'application/zip': ['.zip']}
                            }]
                        });
                        const writable = await handle.createWritable();
                        await writable.write(content);
                        await writable.close();
                    } else {
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(content);
                        a.download = "frames.zip";
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    }
                });
            } else {
                for (let i = 0; i < totalFrames; i++) {
                    await extractFrameAndDownload(i);
                }
            }
        });

        async function extractFrameToZip(idx, zip) {
            return new Promise(resolve => {
                video.currentTime = Math.min(idx * frameInterval, duration - 0.01);
                video.onseeked = function() {
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    canvas.toBlob(function(blob) {
                        zip.file(`frame_${(idx * frameInterval).toFixed(2)}s.png`, blob);
                        resolve();
                    }, 'image/png');
                };
            });
        }

        async function extractFrameAndDownload(idx) {
            return new Promise(resolve => {
                video.currentTime = Math.min(idx * frameInterval, duration - 0.01);
                video.onseeked = async function() {
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    canvas.toBlob(async function(blob) {
                        if (confirm(`Download frame at ${(idx * frameInterval).toFixed(2)}s?`)) {
                            await saveBlobWithPicker(blob, `frame_${(idx * frameInterval).toFixed(2)}s.png`);
                        }
                        resolve();
                    }, 'image/png');
                };
            });
        }
    </script>
</body>
</html>